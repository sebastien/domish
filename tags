!_TAG_EXTRA_DESCRIPTION	anonymous	/Include tags for non-named objects like lambda/
!_TAG_EXTRA_DESCRIPTION	fileScope	/Include tags of file scope/
!_TAG_EXTRA_DESCRIPTION	pseudo	/Include pseudo tags/
!_TAG_EXTRA_DESCRIPTION	subparser	/Include tags generated by subparsers/
!_TAG_FIELD_DESCRIPTION	epoch	/the last modified time of the input file (only for F\/file kind tag)/
!_TAG_FIELD_DESCRIPTION	file	/File-restricted scoping/
!_TAG_FIELD_DESCRIPTION	input	/input file/
!_TAG_FIELD_DESCRIPTION	name	/tag name/
!_TAG_FIELD_DESCRIPTION	pattern	/pattern/
!_TAG_FIELD_DESCRIPTION	typeref	/Type and name of a variable or typedef/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_KIND_DESCRIPTION!TypeScript	C,constant	/constants/
!_TAG_KIND_DESCRIPTION!TypeScript	G,generator	/generators/
!_TAG_KIND_DESCRIPTION!TypeScript	a,alias	/aliases/
!_TAG_KIND_DESCRIPTION!TypeScript	c,class	/classes/
!_TAG_KIND_DESCRIPTION!TypeScript	e,enumerator	/enumerators (values inside an enumeration)/
!_TAG_KIND_DESCRIPTION!TypeScript	f,function	/functions/
!_TAG_KIND_DESCRIPTION!TypeScript	g,enum	/enums/
!_TAG_KIND_DESCRIPTION!TypeScript	i,interface	/interfaces/
!_TAG_KIND_DESCRIPTION!TypeScript	m,method	/methods/
!_TAG_KIND_DESCRIPTION!TypeScript	n,namespace	/namespaces/
!_TAG_KIND_DESCRIPTION!TypeScript	p,property	/properties/
!_TAG_KIND_DESCRIPTION!TypeScript	v,variable	/variables/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_OUTPUT_VERSION	0.0	/current.age/
!_TAG_PARSER_VERSION!TypeScript	0.0	/current.age/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/sebastien/Workspace/Perso/scratchpad/journal/2025-09-Effectors/deps/domish/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	6.1.0	//
ATTRIBUTE_NODE	src/ts/domish.ts	/^	static ATTRIBUTE_NODE = 2;$/;"	p	class:Node
AttributeNode	src/ts/domish.ts	/^export class AttributeNode extends Node {$/;"	c
CDATA_SECTION_NODE	src/ts/domish.ts	/^	static CDATA_SECTION_NODE = 4;$/;"	p	class:Node
COMMENT_NODE	src/ts/domish.ts	/^	static COMMENT_NODE = 8;$/;"	p	class:Node
Comment	src/ts/domish.ts	/^export class Comment extends Node {$/;"	c
DOCUMENT_FRAGMENT_NODE	src/ts/domish.ts	/^	static DOCUMENT_FRAGMENT_NODE = 11;$/;"	p	class:Node
DOCUMENT_NODE	src/ts/domish.ts	/^	static DOCUMENT_NODE = 9;$/;"	p	class:Node
DOCUMENT_TYPE_NODE	src/ts/domish.ts	/^	static DOCUMENT_TYPE_NODE = 10;$/;"	p	class:Node
DOM	src/ts/domish.ts	/^const DOM = {$/;"	C
DataSetProxy	src/ts/domish.ts	/^class DataSetProxy {$/;"	c
Document	src/ts/domish.ts	/^	Document,$/;"	C
Document	src/ts/domish.ts	/^export class Document extends Node {$/;"	c
DocumentFragment	src/ts/domish.ts	/^export class DocumentFragment extends Node {$/;"	c
ELEMENT_NODE	src/ts/domish.ts	/^	static ELEMENT_NODE = 1;$/;"	p	class:Node
ENTITIES	src/ts/xmlish.ts	/^const ENTITIES: { [key: string]: string } = {$/;"	C
Element	src/ts/domish.ts	/^	Element,$/;"	C
Element	src/ts/domish.ts	/^export class Element extends Node {$/;"	c
Fragment	src/ts/xmlish.ts	/^class Fragment {$/;"	c
HTML_EMPTY	src/ts/domish.ts	/^const HTML_EMPTY = tags($/;"	C
HTML_NOEMPTY	src/ts/domish.ts	/^const HTML_NOEMPTY = tags("slot");$/;"	C
LineBreak	src/ts/markish.ts	/^const LineBreak = Symbol.for("LineBreak");$/;"	C
Marker	src/ts/xmlish.ts	/^class Marker {$/;"	c
MarkerType	src/ts/xmlish.ts	/^const MarkerType = Object.freeze({$/;"	C
MatchFragment	src/ts/xmlish.ts	/^class MatchFragment {$/;"	c
Namespaces	src/ts/domish.ts	/^	static Namespaces = {$/;"	p	class:Node
Node	src/ts/domish.ts	/^export class Node {$/;"	c
NodeFilter	src/ts/domish.ts	/^	NodeFilter,$/;"	C
NodeFilter	src/ts/domish.ts	/^export class NodeFilter {$/;"	c
NodeList	src/ts/domish.ts	/^	NodeList,$/;"	C
NodeList	src/ts/domish.ts	/^export const NodeList = Array;$/;"	C
PROCESSING_INSTRUCTION_NODE	src/ts/domish.ts	/^	static PROCESSING_INSTRUCTION_NODE = 7;$/;"	p	class:Node
Query	src/ts/domish.ts	/^class Query {$/;"	c
RE_ATTR_SEP	src/ts/xmlish.ts	/^const RE_ATTR_SEP = \/[=\\s]\/;$/;"	C
RE_ENTITY	src/ts/xmlish.ts	/^const RE_ENTITY = \/&(?:#(?<code>\\d+)|(?<name>[a-z]+));\/gi;$/;"	C
RE_QUERY	src/ts/domish.ts	/^const RE_QUERY =$/;"	C
RE_QUERY_ATTR	src/ts/domish.ts	/^const RE_QUERY_ATTR =$/;"	C
RE_TAG	src/ts/xmlish.ts	/^const RE_TAG = new RegExp($/;"	C
SHOW_ALL	src/ts/domish.ts	/^	static SHOW_ALL = 4294967295;$/;"	p	class:NodeFilter
SHOW_ATTRIBUTE	src/ts/domish.ts	/^	static SHOW_ATTRIBUTE = 2;$/;"	p	class:NodeFilter
SHOW_CDATA_SECTION	src/ts/domish.ts	/^	static SHOW_CDATA_SECTION = 8;$/;"	p	class:NodeFilter
SHOW_COMMENT	src/ts/domish.ts	/^	static SHOW_COMMENT = 128;$/;"	p	class:NodeFilter
SHOW_DOCUMENT	src/ts/domish.ts	/^	static SHOW_DOCUMENT = 256;$/;"	p	class:NodeFilter
SHOW_DOCUMENT_FRAGMENT	src/ts/domish.ts	/^	static SHOW_DOCUMENT_FRAGMENT = 1024;$/;"	p	class:NodeFilter
SHOW_DOCUMENT_TYPE	src/ts/domish.ts	/^	static SHOW_DOCUMENT_TYPE = 512;$/;"	p	class:NodeFilter
SHOW_ELEMENT	src/ts/domish.ts	/^	static SHOW_ELEMENT = 1;$/;"	p	class:NodeFilter
SHOW_ENTITY	src/ts/domish.ts	/^	static SHOW_ENTITY = 32;$/;"	p	class:NodeFilter
SHOW_ENTITY_REFERENCE	src/ts/domish.ts	/^	static SHOW_ENTITY_REFERENCE = 16;$/;"	p	class:NodeFilter
SHOW_NOTATION	src/ts/domish.ts	/^	static SHOW_NOTATION = 2048;$/;"	p	class:NodeFilter
SHOW_PROCESSING	src/ts/domish.ts	/^	static SHOW_PROCESSING = 64;$/;"	p	class:NodeFilter
SHOW_TEXT	src/ts/domish.ts	/^	static SHOW_TEXT = 4;$/;"	p	class:NodeFilter
Selector	src/ts/domish.ts	/^interface Selector {$/;"	i
Space	src/ts/markish.ts	/^const Space = Symbol.for("Space");$/;"	C
StyleSheet	src/ts/domish.ts	/^export class StyleSheet {$/;"	c
StyleSheetList	src/ts/domish.ts	/^	StyleSheetList,$/;"	C
StyleSheetList	src/ts/domish.ts	/^export const StyleSheetList = Array;$/;"	C
TEXT_NODE	src/ts/domish.ts	/^	static TEXT_NODE = 3;$/;"	p	class:Node
TemplateElement	src/ts/domish.ts	/^export class TemplateElement extends Element {$/;"	c
TextNode	src/ts/domish.ts	/^export class TextNode extends Node {$/;"	c
TokenList	src/ts/domish.ts	/^export class TokenList {$/;"	c
TreeWalker	src/ts/domish.ts	/^export class TreeWalker {$/;"	c
_	src/ts/markish.ts	/^				for (const _ of children) {$/;"	C	generator:imarkdown
_	src/ts/markish.ts	/^		for (const _ of node) {$/;"	C	generator:imarkdown
_	src/ts/markish.ts	/^	for (const _ of imarkdown(node)) {$/;"	C	function:markdown
_attach	src/ts/domish.ts	/^	_attach(parentNode: Node): Node {$/;"	m	class:Node
_attributes	src/ts/domish.ts	/^	_attributes: Map<string, AttributeNode>;$/;"	p	class:Element
_attributesNS	src/ts/domish.ts	/^	_attributesNS: Map<string, Map<string, AttributeNode>>;$/;"	p	class:Element
_create	src/ts/domish.ts	/^	_create(): Document {$/;"	m	class:Document
_create	src/ts/domish.ts	/^	_create(): Element {$/;"	m	class:Element
_create	src/ts/domish.ts	/^	_create(): Node {$/;"	m	class:Comment
_create	src/ts/domish.ts	/^	_create(): Node {$/;"	m	class:Node
_create	src/ts/domish.ts	/^	_create(): Node {$/;"	m	class:TextNode
_detach	src/ts/domish.ts	/^	_detach(): Node {$/;"	m	class:Node
_elements	src/ts/domish.ts	/^	_elements: Element[];$/;"	p	class:Document
_get	src/ts/domish.ts	/^	_get(): string {$/;"	m	class:TokenList
_getSiblingAt	src/ts/domish.ts	/^	_getSiblingAt(index: number, offset = 0): Node | null {$/;"	m	class:Node
_index	src/ts/domish.ts	/^	get _index(): number {$/;"	m	class:Node
_register	src/ts/domish.ts	/^	_register(element: Element): Element {$/;"	m	class:Document
_set	src/ts/domish.ts	/^	_set(value: string): void {$/;"	m	class:TokenList
_value	src/ts/domish.ts	/^	_value: string | undefined;$/;"	p	class:AttributeNode
add	src/ts/domish.ts	/^	add(value: string): void {$/;"	m	class:TokenList
after	src/ts/domish.ts	/^	after(...nodes: Node[]): Node {$/;"	m	class:Node
appendChild	src/ts/domish.ts	/^	appendChild(node: Node): Node {$/;"	m	class:Node
appendChild	src/ts/domish.ts	/^	appendChild(node: Node): TemplateElement {$/;"	m	class:TemplateElement
attr	src/ts/domish.ts	/^				const attr = nsMap ? nsMap.get(this.name) : null;$/;"	C	method:AttributeNode.value
attr	src/ts/domish.ts	/^				const attr = this.ownerElement._attributes.get(this.name);$/;"	C	method:AttributeNode.value
attr	src/ts/domish.ts	/^			const attr = nsMap.get(name);$/;"	C	method:Element.getAttributeNS
attr	src/ts/domish.ts	/^			const attr = target._attributes.get(`data-${property}`);$/;"	C	method:DataSetProxy.get
attr	src/ts/domish.ts	/^		const attr = this._attributes.get(name);$/;"	C	method:Element.getAttribute
attrNode	src/ts/domish.ts	/^		const attrNode = new AttributeNode(name, ns, this);$/;"	C	method:Element.setAttributeNS
attrNode	src/ts/domish.ts	/^		const attrNode = new AttributeNode(name, null, this);$/;"	C	method:Element.setAttribute
attribute	src/ts/domish.ts	/^	attribute: string;$/;"	p	class:TokenList
attributes	src/ts/domish.ts	/^			const { type, name, attributes } = this.selectors[i];$/;"	C	method:Query.match
attributes	src/ts/domish.ts	/^	attributes: {$/;"	p	interface:Selector
attributes	src/ts/domish.ts	/^	get attributes(): AttributeNode[] {$/;"	m	class:Element
attributes	src/ts/xmlish.ts	/^	attributes: { [key: string]: string };$/;"	p	class:Marker
attrs	src/ts/domish.ts	/^					const attrs = match.groups?.attributes$/;"	C	method:Query.constructor
attrs	src/ts/domish.ts	/^		for (const [ns, attrs] of this._attributesNS.entries()) {$/;"	C	method:Element.cloneNode
attrs	src/ts/xmlish.ts	/^			const { closing, qualname, ns, name, attrs } = match.groups as { closing?: string; qualname?:/;"	C	generator:iterMarkers
attrs_map	src/ts/xmlish.ts	/^			const attrs_map: { [key: string]: any } = {};$/;"	C	generator:iterMarkers
before	src/ts/domish.ts	/^	before(...nodes: Node[]): Node {$/;"	m	class:Node
body	src/ts/domish.ts	/^	body: Element;$/;"	p	class:Document
c	src/ts/xmlish.ts	/^			const c = Number(code);$/;"	C	generator:iexpandEntities
child	src/ts/domish.ts	/^			const child = this.childNodes[i];$/;"	C	method:Node.removeChild
child	src/ts/domish.ts	/^			for (const child of children) {$/;"	C	method:Node.insertBefore
childNodes	src/ts/domish.ts	/^	childNodes: Node[];$/;"	p	class:Node
children	src/ts/domish.ts	/^			const children = [...(node as DocumentFragment).childNodes];$/;"	C	method:Node.appendChild
children	src/ts/domish.ts	/^			const children = [...fragment.childNodes]; \/\/ Create a copy to avoid mutation issues$/;"	C	method:Node.insertBefore
children	src/ts/domish.ts	/^	get children(): Node[] {$/;"	m	class:Node
chr	src/ts/xmlish.ts	/^		const chr = text[m.index! + 1];$/;"	C
classList	src/ts/domish.ts	/^	classList: TokenList;$/;"	p	class:Element
cloneNode	src/ts/domish.ts	/^	cloneNode(deep = false): Node {$/;"	m	class:Node
cloneNode	src/ts/domish.ts	/^	cloneNode(deep?: boolean): Element {$/;"	m	class:Element
clonedAttr	src/ts/domish.ts	/^					const clonedAttr = new AttributeNode(k, ns, res);$/;"	C	method:Element.cloneNode
clonedAttr	src/ts/domish.ts	/^				const clonedAttr = new AttributeNode(k, null, res);$/;"	C	method:Element.cloneNode
clonedNsMap	src/ts/domish.ts	/^			const clonedNsMap = new Map();$/;"	C	method:Element.cloneNode
closing	src/ts/xmlish.ts	/^			const { closing, qualname, ns, name, attrs } = match.groups as { closing?: string; qualname?:/;"	C	generator:iterMarkers
code	src/ts/xmlish.ts	/^		const { code, name } = groups;$/;"	C	generator:iexpandEntities
comment	src/ts/xmlish.ts	/^						const comment = doc.createComment(marker.fragment.rawtext);$/;"	C	function:parse
constructor	src/ts/domish.ts	/^	constructor($/;"	m	class:AttributeNode
constructor	src/ts/domish.ts	/^	constructor() {$/;"	m	class:DocumentFragment
constructor	src/ts/domish.ts	/^	constructor() {$/;"	m	class:StyleSheet
constructor	src/ts/domish.ts	/^	constructor(data: string) {$/;"	m	class:Comment
constructor	src/ts/domish.ts	/^	constructor(data: string) {$/;"	m	class:TextNode
constructor	src/ts/domish.ts	/^	constructor(element: Element, attribute = "class") {$/;"	m	class:TokenList
constructor	src/ts/domish.ts	/^	constructor(name: string, namespace: string | null = null) {$/;"	m	class:Element
constructor	src/ts/domish.ts	/^	constructor(name: string, namespace: string | null = null) {$/;"	m	class:TemplateElement
constructor	src/ts/domish.ts	/^	constructor(name: string, type: number) {$/;"	m	class:Node
constructor	src/ts/domish.ts	/^	constructor(nodes?: Node[]) {$/;"	m	class:Document
constructor	src/ts/domish.ts	/^	constructor(query: string) {$/;"	m	class:Query
constructor	src/ts/xmlish.ts	/^	constructor(match: RegExpExecArray | null, fragment: Fragment) {$/;"	m	class:MatchFragment
constructor	src/ts/xmlish.ts	/^	constructor(source: string, start: number, end: number) {$/;"	m	class:Fragment
constructor	src/ts/xmlish.ts	/^	constructor(type: string, fragment: Fragment, name: string | null = null, attributes: { [key: s/;"	m	class:Marker
contains	src/ts/domish.ts	/^	contains(value: string): boolean {$/;"	m	class:TokenList
content	src/ts/domish.ts	/^	content: DocumentFragment;$/;"	p	class:TemplateElement
createAttribute	src/ts/domish.ts	/^	createAttribute(name: string): AttributeNode {$/;"	m	class:Document
createComment	src/ts/domish.ts	/^	createComment(value: string): Comment {$/;"	m	class:Document
createDocumentFragment	src/ts/domish.ts	/^	createDocumentFragment(): DocumentFragment {$/;"	m	class:Document
createElement	src/ts/domish.ts	/^	createElement(name: string): Element {$/;"	m	class:Document
createElementNS	src/ts/domish.ts	/^	createElementNS(namespace: string, name: string): Element {$/;"	m	class:Document
createTextNode	src/ts/domish.ts	/^	createTextNode(value: string): TextNode {$/;"	m	class:Document
createTreeWalker	src/ts/domish.ts	/^	createTreeWalker(node: Node, nodeFilter: number): TreeWalker {$/;"	m	class:Document
cssRules	src/ts/domish.ts	/^	cssRules: string[];$/;"	p	class:StyleSheet
currentNode	src/ts/domish.ts	/^	currentNode: Node;$/;"	p	class:TreeWalker
data	src/ts/domish.ts	/^	data: string;$/;"	p	class:Node
dataset	src/ts/domish.ts	/^	dataset: any;$/;"	p	class:Element
deleteRule	src/ts/domish.ts	/^	deleteRule(index: number): StyleSheet {$/;"	m	class:StyleSheet
derive	src/ts/markish.ts	/^function derive(object: any, data: any = {}): any {$/;"	f
doc	src/ts/xmlish.ts	/^	const doc = new Document();$/;"	C	function:parse
document	src/ts/domish.ts	/^	document,$/;"	C
document	src/ts/domish.ts	/^export const document = new Document();$/;"	C
element	src/ts/domish.ts	/^	element: Element;$/;"	p	class:TokenList
element	src/ts/xmlish.ts	/^						const element = doc.createElement(name);$/;"	C	function:parse
element	src/ts/xmlish.ts	/^					const element = doc.createElement(name);$/;"	C	function:parse
end	src/ts/xmlish.ts	/^		const end = start + match[0].length;$/;"	C	generator:iexpandEntities
end	src/ts/xmlish.ts	/^		const end =$/;"	C
end	src/ts/xmlish.ts	/^	end: number;$/;"	p	class:Fragment
expandEntities	src/ts/xmlish.ts	/^function expandEntities(text: string): string {$/;"	f
firstChild	src/ts/domish.ts	/^	get firstChild(): Node | undefined {$/;"	m	class:Node
fragment	src/ts/xmlish.ts	/^	for (const { match, fragment } of Fragment.IterMatches(RE_TAG, text)) {$/;"	C	generator:iterMarkers
fragment	src/ts/xmlish.ts	/^	fragment: Fragment;$/;"	p	class:Marker
fragment	src/ts/xmlish.ts	/^	fragment: Fragment;$/;"	p	class:MatchFragment
get	src/ts/domish.ts	/^	static get(target: Element, property: string | symbol): any {$/;"	m	class:DataSetProxy
getAttribute	src/ts/domish.ts	/^	getAttribute(name: string): string | null {$/;"	m	class:Element
getAttributeNS	src/ts/domish.ts	/^	getAttributeNS(ns: string, name: string): string | null {$/;"	m	class:Element
getAttributeNode	src/ts/domish.ts	/^	getAttributeNode(name: string): AttributeNode | null {$/;"	m	class:Element
getAttributeNodeNS	src/ts/domish.ts	/^	getAttributeNodeNS(ns: string, name: string): AttributeNode | null {$/;"	m	class:Element
getElementById	src/ts/domish.ts	/^	getElementById(id: string): Element | null {$/;"	m	class:Document
gi	src/ts/xmlish.ts	/^const RE_ENTITY = \/&(?:#(?<code>\\d+)|(?<name>[a-z]+));\/gi;$/;"	C
groups	src/ts/xmlish.ts	/^		const groups = match.groups as any;$/;"	C	generator:iexpandEntities
hasAttribute	src/ts/domish.ts	/^	hasAttribute(name: string): boolean {$/;"	m	class:Element
hasAttributeNS	src/ts/domish.ts	/^	hasAttributeNS(namespace: string, name: string): boolean {$/;"	m	class:Element
hasChildNodes	src/ts/domish.ts	/^	hasChildNodes(): boolean {$/;"	m	class:Node
i	src/ts/domish.ts	/^			const child = this.childNodes[i];$/;"	C	method:Node.removeChild
i	src/ts/domish.ts	/^			const n = this._elements[i];$/;"	C	method:Document.getElementById
i	src/ts/domish.ts	/^			const node = nodes[i];$/;"	C	method:Node.after
i	src/ts/domish.ts	/^			const node = nodes[i];$/;"	C	method:Node.before
i	src/ts/domish.ts	/^			const { type, name, attributes } = this.selectors[i];$/;"	C	method:Query.match
i	src/ts/domish.ts	/^		const i = this.childNodes.indexOf(child);$/;"	C	method:Node.removeChild
i	src/ts/domish.ts	/^		const i = this.childNodes.indexOf(oldChild);$/;"	C	method:Node.replaceChild
i	src/ts/domish.ts	/^		const i = this.childNodes.indexOf(referenceNode);$/;"	C	method:Node.insertBefore
i	src/ts/xmlish.ts	/^		const i = start >= 0 ? this.start + start : this.end + start;$/;"	C	method:Fragment.slice
id	src/ts/domish.ts	/^	get id(): string | null {$/;"	m	class:Element
iexpandEntities	src/ts/xmlish.ts	/^function* iexpandEntities(text: string): Generator<string> {$/;"	G
if	src/ts/domish.ts	/^		if (newNode.parentNode) {$/;"	m	class:Node
imarkdown	src/ts/markish.ts	/^function* imarkdown(node: any, context: any = {}): Generator<any> {$/;"	G
index	src/ts/markish.ts	/^						const index = is_ol ? `${context.index + 1}.` : "-";$/;"	C	generator:imarkdown
innerHTML	src/ts/domish.ts	/^	get innerHTML(): string {$/;"	m	class:Node
innerText	src/ts/domish.ts	/^	get innerText(): string {$/;"	m	class:Node
insertBefore	src/ts/domish.ts	/^	insertBefore(newNode: Node, referenceNode: Node | null): Node {$/;"	m	class:Node
insertRule	src/ts/domish.ts	/^	insertRule(rule: string, index = 0): StyleSheet {$/;"	m	class:StyleSheet
install	src/ts/domish.ts	/^export function install($/;"	f
isConnected	src/ts/domish.ts	/^	get isConnected(): boolean | undefined {$/;"	m	class:Node
is_closing	src/ts/xmlish.ts	/^			const is_closing = !!closing;$/;"	C	generator:iterMarkers
is_ol	src/ts/markish.ts	/^						const is_ol = context?.container === "ol";$/;"	C	generator:imarkdown
is_self_closing	src/ts/xmlish.ts	/^			const is_self_closing = match[0].endsWith("\/>");$/;"	C	generator:iterMarkers
iterMarkers	src/ts/xmlish.ts	/^function* iterMarkers(text: string): Generator<Marker> {$/;"	G
iterWalk	src/ts/domish.ts	/^	iterWalk(callback: (node: Node) => boolean | void): void {$/;"	m	class:Node
j	src/ts/xmlish.ts	/^		const j = end && end >= 0 ? this.start + end : this.end + (end || 0);$/;"	C	method:Fragment.slice
k	src/ts/domish.ts	/^			for (const [k, v] of attrs.entries()) {$/;"	C	method:Element.cloneNode
k	src/ts/domish.ts	/^		for (const [k, v] of this._attributes.entries()) {$/;"	C	method:Element.cloneNode
k	src/ts/xmlish.ts	/^						for (const [k, v] of Object.entries(marker.attributes)) {$/;"	C	function:parse
k	src/ts/xmlish.ts	/^					for (const [k, v] of Object.entries(marker.attributes)) {$/;"	C	function:parse
lastChild	src/ts/domish.ts	/^	get lastChild(): Node | null {$/;"	m	class:Node
length	src/ts/xmlish.ts	/^	get length(): number {$/;"	m	class:Fragment
m	src/ts/xmlish.ts	/^		const chr = text[m.index! + 1];$/;"	C
m	src/ts/xmlish.ts	/^	const m = text.match(RE_ATTR_SEP);$/;"	C
markdown	src/ts/markish.ts	/^export function markdown(node: any): string {$/;"	f
marker	src/ts/xmlish.ts	/^	for (const marker of iterMarkers(text)) {$/;"	C	function:parse
match	src/ts/domish.ts	/^	match(node: Node): boolean {$/;"	m	class:Query
match	src/ts/xmlish.ts	/^	for (const { match, fragment } of Fragment.IterMatches(RE_TAG, text)) {$/;"	C	generator:iterMarkers
match	src/ts/xmlish.ts	/^	match: RegExpExecArray | null;$/;"	p	class:MatchFragment
matched	src/ts/domish.ts	/^				const matched: Node[] = [];$/;"	C	method:Node.querySelectorAll
matches	src/ts/domish.ts	/^		const matches = query.match(RE_QUERY);$/;"	C	method:Query.constructor
matches	src/ts/domish.ts	/^	matches(query: string): boolean {$/;"	m	class:Node
n	src/ts/domish.ts	/^				for (const n of scope) {$/;"	C	method:Node.querySelectorAll
n	src/ts/domish.ts	/^			const n = this._elements[i];$/;"	C	method:Document.getElementById
n	src/ts/domish.ts	/^			for (const n of children) {$/;"	C	method:Node.appendChild
n	src/ts/domish.ts	/^		const n = this._create();$/;"	C	method:Node.cloneNode
n	src/ts/domish.ts	/^		const n = this.childNodes.length;$/;"	C	method:Node.lastChild
name	src/ts/domish.ts	/^			const { type, name, attributes } = this.selectors[i];$/;"	C	method:Query.match
name	src/ts/domish.ts	/^	name: string;$/;"	p	class:AttributeNode
name	src/ts/domish.ts	/^	name: string;$/;"	p	interface:Selector
name	src/ts/markish.ts	/^		const name = (node.nodeName ?? "").toLowerCase();$/;"	C	generator:imarkdown
name	src/ts/xmlish.ts	/^					const name = marker.name!;$/;"	C	function:parse
name	src/ts/xmlish.ts	/^			const name = text.substring(0, spaceIndex).trim();$/;"	C
name	src/ts/xmlish.ts	/^			const name = text.trim();$/;"	C
name	src/ts/xmlish.ts	/^			const { closing, qualname, ns, name, attrs } = match.groups as { closing?: string; qualname?:/;"	C	generator:iterMarkers
name	src/ts/xmlish.ts	/^		const name = text.substring(0, m.index!).trim();$/;"	C
name	src/ts/xmlish.ts	/^		const { code, name } = groups;$/;"	C	generator:iexpandEntities
name	src/ts/xmlish.ts	/^	name: string | null;$/;"	p	class:Marker
namespace	src/ts/domish.ts	/^		for (const [namespace, nsMap] of this._attributesNS.entries()) {$/;"	C	method:Element.removeAttribute
namespace	src/ts/domish.ts	/^	namespace: string | null;$/;"	p	class:AttributeNode
namespace	src/ts/domish.ts	/^	namespace: string | null;$/;"	p	class:Element
namespacedAttrs	src/ts/domish.ts	/^		const namespacedAttrs: AttributeNode[] = [];$/;"	C	method:Element.attributes
next	src/ts/domish.ts	/^		const next = this.nextSibling;$/;"	C	method:Node.after
next	src/ts/domish.ts	/^		let next = this._nextNode(this.currentNode);$/;"	v
nextSibling	src/ts/domish.ts	/^	get nextSibling(): Node | null {$/;"	m	class:Node
node	src/ts/domish.ts	/^			const node = nodes[i];$/;"	C	method:Node.after
node	src/ts/domish.ts	/^			const node = nodes[i];$/;"	C	method:Node.before
node	src/ts/domish.ts	/^			for (const node of nodes) {$/;"	C	method:Document.constructor
node	src/ts/domish.ts	/^			let node: Node | null = this.currentNode.parentNode;$/;"	v
nodeFilter	src/ts/domish.ts	/^	nodeFilter: number;$/;"	p	class:TreeWalker
nodeName	src/ts/domish.ts	/^	nodeName: string;$/;"	p	class:Node
nodeType	src/ts/domish.ts	/^	nodeType: number;$/;"	p	class:Node
nodeValue	src/ts/domish.ts	/^	get nodeValue(): string {$/;"	m	class:AttributeNode
nodeValue	src/ts/domish.ts	/^	get nodeValue(): string {$/;"	m	class:Comment
nodeValue	src/ts/domish.ts	/^	get nodeValue(): string {$/;"	m	class:TextNode
nodeValue	src/ts/domish.ts	/^	get nodeValue(): string | null | undefined {$/;"	m	class:Node
ns	src/ts/domish.ts	/^		for (const [ns, attrs] of this._attributesNS.entries()) {$/;"	C	method:Element.cloneNode
ns	src/ts/xmlish.ts	/^			const { closing, qualname, ns, name, attrs } = match.groups as { closing?: string; qualname?:/;"	C	generator:iterMarkers
nsMap	src/ts/domish.ts	/^				const attr = nsMap ? nsMap.get(this.name) : null;$/;"	C	method:AttributeNode.value
nsMap	src/ts/domish.ts	/^				const nsMap = this.ownerElement._attributesNS.get($/;"	C	method:AttributeNode.value
nsMap	src/ts/domish.ts	/^		const nsMap = this._attributesNS.get(ns);$/;"	C	method:Element.getAttributeNS
nsMap	src/ts/domish.ts	/^		const nsMap = this._attributesNS.get(ns);$/;"	C	method:Element.getAttributeNodeNS
nsMap	src/ts/domish.ts	/^		for (const [namespace, nsMap] of this._attributesNS.entries()) {$/;"	C	method:Element.removeAttribute
nsMap	src/ts/domish.ts	/^		for (const nsMap of this._attributesNS.values()) {$/;"	C	method:Element.attributes
outerHTML	src/ts/domish.ts	/^	get outerHTML(): string {$/;"	m	class:Node
ownerDocument	src/ts/domish.ts	/^	get ownerDocument(): Document | undefined {$/;"	m	class:Node
ownerElement	src/ts/domish.ts	/^	ownerElement: Element | null;$/;"	p	class:AttributeNode
parent	src/ts/domish.ts	/^		const parent = this.parentNode;$/;"	C	method:Node.after
parent	src/ts/domish.ts	/^		const parent = this.parentNode;$/;"	C	method:Node.before
parentElement	src/ts/domish.ts	/^	get parentElement(): Node | null {$/;"	m	class:Node
parentNode	src/ts/domish.ts	/^	parentNode: Node | null;$/;"	p	class:Node
parse	src/ts/xmlish.ts	/^export function parse(text: string): Document {$/;"	f
parseAttributes	src/ts/xmlish.ts	/^export const parseAttributes = (text: string, attributes: { [key: string]: any } = {}): { [key: /;"	C
prefix	src/ts/markish.ts	/^		const prefix = Array((context?.indent ?? 0) + 1).join("  ");$/;"	C	generator:imarkdown
previousSibling	src/ts/domish.ts	/^	get previousSibling(): Node | null {$/;"	m	class:Node
q	src/ts/domish.ts	/^				const q = new Query(query);$/;"	C	method:Node.querySelectorAll
qs	src/ts/domish.ts	/^		for (const qs of query.split(\/\\s+\/)) {$/;"	C	method:Node.querySelectorAll
qualname	src/ts/xmlish.ts	/^			const { closing, qualname, ns, name, attrs } = match.groups as { closing?: string; qualname?:/;"	C	generator:iterMarkers
querySelector	src/ts/domish.ts	/^	querySelector(query: string): Node | undefined {$/;"	m	class:Node
querySelectorAll	src/ts/domish.ts	/^	querySelectorAll(query: string): Node[] {$/;"	m	class:Node
r	src/ts/domish.ts	/^					const r = _.cloneNode(deep);$/;"	C	method:Node.cloneNode
rawtext	src/ts/xmlish.ts	/^	get rawtext(): string {$/;"	m	class:Fragment
regularAttrs	src/ts/domish.ts	/^		const regularAttrs = Array.from(this._attributes.values());$/;"	C	method:Element.attributes
remove	src/ts/domish.ts	/^	remove(value: string): void {$/;"	m	class:TokenList
removeAttribute	src/ts/domish.ts	/^	removeAttribute(name: string): void {$/;"	m	class:Element
removeAttributeNS	src/ts/domish.ts	/^	removeAttributeNS(namespace: string, name: string): void {$/;"	m	class:Element
removeChild	src/ts/domish.ts	/^	removeChild(child: Node): Node {$/;"	m	class:Node
replaceChild	src/ts/domish.ts	/^	replaceChild(newChild: Node, oldChild: Node): Node {$/;"	m	class:Node
res	src/ts/domish.ts	/^		const res = super.cloneNode(deep) as Element;$/;"	C	method:Element.cloneNode
res	src/ts/markish.ts	/^	const res: string[] = [];$/;"	C	function:markdown
root	src/ts/domish.ts	/^	root: Node;$/;"	p	class:TreeWalker
selectors	src/ts/domish.ts	/^	selectors: Selector[];$/;"	p	class:Query
setAttribute	src/ts/domish.ts	/^	setAttribute(name: string, value: string): void {$/;"	m	class:Element
setAttributeNS	src/ts/domish.ts	/^	setAttributeNS(ns: string, name: string, value: string): void {$/;"	m	class:Element
setAttributeNode	src/ts/domish.ts	/^	setAttributeNode(node: AttributeNode): void {$/;"	m	class:Element
setNodeValue	src/ts/domish.ts	/^	setNodeValue(value: string): void {$/;"	m	class:AttributeNode
sheet	src/ts/domish.ts	/^	sheet: StyleSheet | null;$/;"	p	class:Element
slice	src/ts/xmlish.ts	/^	slice(start = 0, end: number | null = null): Fragment {$/;"	m	class:Fragment
source	src/ts/xmlish.ts	/^	source: string;$/;"	p	class:Fragment
spaceIndex	src/ts/xmlish.ts	/^		const spaceIndex = text.indexOf(" ");$/;"	C
stack	src/ts/xmlish.ts	/^	const stack: any[] = [doc];$/;"	C	function:parse
start	src/ts/xmlish.ts	/^		const start = match.index;$/;"	C	generator:iexpandEntities
start	src/ts/xmlish.ts	/^	start: number;$/;"	p	class:Fragment
strip	src/ts/markish.ts	/^function strip(text: string): string {$/;"	f
style	src/ts/domish.ts	/^	style: { [key: string]: string };$/;"	p	class:Element
tags	src/ts/domish.ts	/^const tags = (...tags: string[]): Map<string, boolean> =>$/;"	C
text	src/ts/domish.ts	/^	text: string;$/;"	p	class:Query
text	src/ts/markish.ts	/^							const text = strip(node.textContent);$/;"	C	generator:imarkdown
text	src/ts/markish.ts	/^				const text = strip(node.textContent);$/;"	C	generator:imarkdown
text	src/ts/xmlish.ts	/^					const text = expandEntities(marker.text);$/;"	C	function:parse
text	src/ts/xmlish.ts	/^	get text(): string {$/;"	m	class:Fragment
textContent	src/ts/domish.ts	/^	get textContent(): string {$/;"	m	class:Node
this	src/ts/domish.ts	/^		this.childNodes.splice(i, 0, newNode);$/;"	m	class:Node
toCSSPropertyName	src/ts/domish.ts	/^const toCSSPropertyName = (name: string): string => {$/;"	C
toHTML	src/ts/domish.ts	/^	toHTML(options: { [key: string]: any } = {}): string {$/;"	m	class:Node
toJSON	src/ts/domish.ts	/^	toJSON(): any {$/;"	m	class:Node
toJSON	src/ts/domish.ts	/^	toJSON(): string {$/;"	m	class:TextNode
toJSON	src/ts/domish.ts	/^	toJSON(): undefined {$/;"	m	class:Comment
toJSON	src/ts/domish.ts	/^	toJSON(): {$/;"	m	class:Element
toString	src/ts/xmlish.ts	/^	toString(): string {$/;"	m	class:Fragment
toText	src/ts/domish.ts	/^	toText(options?: { [key: string]: any }): string {$/;"	m	class:Node
toXML	src/ts/domish.ts	/^	toXML(options: { [key: string]: any } = {}): string {$/;"	m	class:Node
toXMLLines	src/ts/domish.ts	/^	toXMLLines(options?: { [key: string]: any }): string[] {$/;"	m	class:Node
toggle	src/ts/domish.ts	/^	toggle(value: string): boolean {$/;"	m	class:TokenList
type	src/ts/domish.ts	/^			const { type, name, attributes } = this.selectors[i];$/;"	C	method:Query.match
type	src/ts/domish.ts	/^	type: string;$/;"	p	interface:Selector
type	src/ts/xmlish.ts	/^	type: string;$/;"	p	class:Marker
v	src/ts/domish.ts	/^			const v = this._get();$/;"	C	method:TokenList.add
v	src/ts/domish.ts	/^			for (const [k, v] of attrs.entries()) {$/;"	C	method:Element.cloneNode
v	src/ts/domish.ts	/^		for (const [k, v] of this._attributes.entries()) {$/;"	C	method:Element.cloneNode
v	src/ts/xmlish.ts	/^						for (const [k, v] of Object.entries(marker.attributes)) {$/;"	C	function:parse
v	src/ts/xmlish.ts	/^					for (const [k, v] of Object.entries(marker.attributes)) {$/;"	C	function:parse
value	src/ts/domish.ts	/^	get value(): string {$/;"	m	class:AttributeNode
value	src/ts/domish.ts	/^	set value(value: string) {$/;"	m	class:AttributeNode
value	src/ts/xmlish.ts	/^		const value =$/;"	C
